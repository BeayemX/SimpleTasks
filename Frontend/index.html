<html>
<head>
    <title>Simple tasks</title>
    <style>
        body {
            background-color: rgb(77, 77, 77);
            background-color: #5a5a5a;
            margin: 0;
            padding: 0;
            color: #ddd;
        }
        #wrapper {
            margin: 0;
            padding: 0;
            display: flex;
            flex-flow: column;
            height: 100%;
            width: 100%;
        }
        #contentContainer {
            display: flex;
            flex-flow: column;
            overflow: auto;
        }
        .spacer{
            flex: 1;
        }
        #inputLine {
            display: flex;
            flex-flow: column;

            padding: 10px;
            background-color: #2a2a2a;
        }
        #inputLine input {
            padding: 5px;

            font-family: 'Roboto', sans-serif;
            font-size: 14pt;
            background-color: #ccc;
        }

        #titleBar {
            display: flex;
            flex-flow: row;
            flex: 0;

            font-family: 'Oswald', sans-serif;

            background-color: #2a2a2a;
            padding: 10px;

            align-items: center;
            /*
            justify-content: center;
            */
        }
        .backbutton {
            flex: 0;
            cursor: pointer;
            font-size: 140%;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }
        .title {
            flex: 1;
            border-bottom: 1px solid #ddd;
            /*
            */
            padding-left: 15px;
            padding-right: 15px;
            padding-top: 5px;
            padding-bottom: 5px;
            margin: 5px;
            cursor: text;
            text-align: center;
            font-size: 18pt;
        }

        .entryWrapper {
            display: flex;
            flex-flow: row;
            flex: 1;

            background-color: #0006;
            border-radius: 3px;

            padding-left: 15px;
            padding-right: 10px;
            padding-top: 7px;
            padding-bottom: 7px;

            margin-left: 10px;
            margin-right: 10px;
            margin-top: 6px;
            margin-bottom: 6px;

            font-family: 'Roboto', sans-serif;
            font-size: 14pt;

            align-items: center;
        }

        .focused{
            /*
            border: 1px solid cyan;
            box-sizing: border-box; // this does not work, it should prevent the content size from resizing when showing border
            */
            border-left: 5px solid cyan;
        }

        .entryEnterButton {
            flex: 1;
            cursor: pointer;
        }
        .icon {
            flex: 0;

            padding: 2;
            padding-left:10;
            padding-right:10;

            margin-left:5;
            margin-right:5;
        }
        .deletebutton {
            font-size: 140%;
            color:red;

            border: 2px solid red;
            border-radius: 100%;

            cursor: pointer;
        }
        .subcounter {
            background-color: #fff3;

            border-radius: 15px;
            padding-left: 15px;
            padding-right: 15px;
            padding-top: 5px;
            padding-bottom: 5px;
            cursor: default;
            /*
            should allow click through...
            pointer-events: none;
            */
        }

    </style>

    <link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">

    <script>
        const URL = 'ws://localhost:7777';
        const RECONNECT_TIMEOUT = 2500;
        let ws;

        function onLoad() {
            console.clear();
            var contentContainer = document.getElementById('contentContainer');
            var inputLine = document.getElementById('inputLine');
            var titleBar = document.getElementById('titleBar');

            createInputLine()

            connectToWebSocket();

            document.onkeydown = globalKeyDownHandler;
        }

        function connectToWebSocket() {
            ws = new WebSocket(URL);
            // Connect to websockets

            ws.addEventListener('open', (event) => {
                console.log("Connected");
            });

            ws.addEventListener('message', (event) => {
                // console.log("Message: ", event.data);
                const jsonData = JSON.parse(event.data);

                if (jsonData['type'] == 'connection_established') {
                    console.log("Connected. SocketID: ", jsonData['id']);
                } else if (jsonData['type'] == 'update_data') {
                    data = jsonData['data'];
                    updateDisplayedData();
                }
            });

            ws.addEventListener('close', (event) => {
                console.log("Close");
                setTimeout(() => {
                    console.log("Trying to reconnect...")
                    connectToWebSocket()
                }, RECONNECT_TIMEOUT);
            });

            ws.addEventListener('error', (event) => {
                console.log("Error connecting.");
            });
        }

        function send(sendData) {
            ws.send(JSON.stringify(sendData));
        }

    </script>
    <script>
        // Configuration
        const cut_off_long_texts = false;

        const TITLE = "Tasks & Notes";
        const DELETE_ICON = "&#10060;";
        const BACK_ARROW = "&#129120;";

        let data = {};
        let currentPath = [];
        let input;

        function getCurrentData() {
            return accessPathData(currentPath)
        }
        function getParentData() {
            const parentPath = copyCurrentPath()
            parentPath.pop();
            return accessPathData(parentPath);
        }

        function accessPathData(path)
        {
            let tmpData = data;
            for (let pathElement of path){
                tmpData = tmpData[pathElement];
            }
            return tmpData;
        }

        function updateDisplayedData() {
            _createEverything(getCurrentData());

            if (pathToEnterWhenReceivingServerUpdate) {
                currentPath = pathToEnterWhenReceivingServerUpdate;
                pathToEnterWhenReceivingServerUpdate = null;
                updateDisplayedData()

            }

            deselectEntries();
            focusInput();

            if (selectedIndexAfterUpdate >= 0) {
                selectEntryWithIndex(selectedIndexAfterUpdate);
                selectedIndexAfterUpdate = -1;
            }
        }

        function focusInput() {
            deselectEntries();
            input.focus();
        }

        let entryElements;
        let selectedIndexAfterUpdate = -1;

        function _createEverything(contentData) {
            contentContainer.innerText = "";

            createTitle();

            const entries = contentData;
            entryElements = [];
            for (let key in entries) {
                const entry = entries[key];
                createEntry(key, entry);
            }
        }
        let titleObject;
        function createTitle() {
            titleBar.innerHTML = '';

            if (currentPath.length > 0) {
                // Create back button
                const backButton = document.createElement('div');
                backButton.setAttribute('class', 'backbutton');
                backButton.innerHTML = BACK_ARROW;

                backButton.onclick = () => {
                    goBack();
                }

                titleBar.appendChild(backButton);
            }

            // Create title text
            titleObject = document.createElement('div');
            titleObject.setAttribute('class', 'title');
            if (currentPath.length > 0)
                titleObject.setAttribute('contenteditable', true);

            let actualTitle = currentPath[currentPath.length -1];
            if (actualTitle)
            {
                const maxLength = 60;
                if (cut_off_long_texts && actualTitle.length > maxLength)
                {
                    actualTitle = actualTitle.substring(0, maxLength) + "..."
                }
            }
            else
            {
                actualTitle = TITLE;
            }

            titleObject.innerText = actualTitle;

            const originalText = actualTitle;

            titleObject.onblur = () => {
                if (titleObject.innerText == originalText)
                    return;

                if (!titleObject.innerText) {
                    titleObject.innerText = originalText;
                } else {
                    sendRename(originalText, titleObject.innerText);
                }
            }
            titleObject.onkeydown = (e) => {
                if (e.key == 'Escape') {
                    titleObject.innerText = originalText;
                    focusInput();
                    return false;
                }
                if (e.key == 'Enter') {
                    focusInput(); // this will call the onblur function
                    return false;
                }
            }
            titleBar.appendChild(titleObject);
        }

        function sendRename(oldName, newName) {
            const path = copyCurrentPath();
            path.pop();

            send({
                'action': 'rename_entry',
                'path': path,
                'old': oldName,
                'new': newName
            })

            pathToEnterWhenReceivingServerUpdate = path;
            pathToEnterWhenReceivingServerUpdate.push(newName)
        }

        function createEntry(entryName, entryData) {
            const newEntryWrapper = document.createElement('div');
            newEntryWrapper.setAttribute('class', 'entryWrapper');

            newEntryWrapper.select = () => {
                newEntryWrapper.classList.add('focused');
            };
            newEntryWrapper.deselect = () => {
                newEntryWrapper.classList.remove('focused');
            };

            newEntryWrapper.enter = () => {
                 // Enter sub-level
                const entries = entryData
                currentPath.push(entryName);
                updateDisplayedData();
                /*
                const stateObj = {
                    "currentPath": currentPath;
                }
                history.pushState(stateObj, )
                */
             }

             newEntryWrapper.delete = (askForConfirmationForSubtasks = true) => {
                if (subTasksCounter > 0 && askForConfirmationForSubtasks) {
                    if (!confirm("There are sub-tasks, do you really want to delete this?"))
                        return;
                }
                const entries = entryData;
                delete getCurrentData()[entryName];

                let deletePath = copyCurrentPath();
                deletePath.push(entryName);
                updateDisplayedData();

                send({
                    'action': 'delete_entry',
                    'path': deletePath
                })
             }


            // Add button to enter sub-level
            const newEntryButton = document.createElement('div');
            let entryText = entryName;
            const maxLength = 256
            if (cut_off_long_texts && entryText.length > maxLength){
                entryText = entryText.substring(0, maxLength) + "..."
            }
            newEntryButton.setAttribute('class', 'entryEnterButton');
            newEntryButton.innerText = entryText;

            newEntryWrapper.appendChild(newEntryButton);

            newEntryButton.onclick = () => {
                newEntryWrapper.enter();
            };

            // Add description
            const description = entryData['description'];
            if (description) {
                const newEntryDescription = document.createElement('div');
                newEntryDescription.innerText = description;
                newEntryWrapper.appendChild(newEntryDescription);
            }

            let subTasksCounter = 0;
            function countSubTasks(subData) {
                for (let key of Object.keys(subData)) {
                    subTasksCounter += 1;
                    countSubTasks(subData[key]);
                }
            }

            countSubTasks(entryData);

            if (subTasksCounter > 0){
                const subTasksCounterLabel = document.createElement('div');
                subTasksCounterLabel.setAttribute('class', 'icon subcounter');
                subTasksCounterLabel.innerText = subTasksCounter;
                newEntryWrapper.appendChild(subTasksCounterLabel);
            }

            // Add delete button
            const deleteButton = document.createElement('div');
            deleteButton.setAttribute('class', 'icon deletebutton');
            deleteButton.innerHTML = DELETE_ICON;
            newEntryWrapper.appendChild(deleteButton);

            deleteButton.onclick = () => {
                newEntryWrapper.delete();
            };

            contentContainer.appendChild(newEntryWrapper);
            entryElements.push(newEntryWrapper);
        }

        function createInputLine() {
            input = document.createElement('input');
            input.onclick = () => {
            }
            input.onkeypress = (e) => {
                if (input.value == "")
                    return;

                if (e.key == 'Enter') {
                    const newEntryText = input.value;
                    input.value = '';

                    if (e.shiftKey) {
                        pathToEnterWhenReceivingServerUpdate = copyCurrentPath()
                        pathToEnterWhenReceivingServerUpdate.push(newEntryText);
                    }

                    addEntry(newEntryText);
                }

            }
            inputLine.appendChild(input);
        }

        function addEntry(text){
            const sendData = {
                'action': 'add_entry',
                'path': currentPath,
                'text': text
            }
            send(sendData);
        }

        function copyCurrentPath() {
            let newPath = []

            for (let part of currentPath)
                newPath.push(part);

            return newPath;
        }

        let pathToEnterWhenReceivingServerUpdate = null

        function goBack() {
            currentPath.pop()
            updateDisplayedData();
        }

        function deselectEntries() {
            for (let element of entryElements)
                element.deselect();

            selectedEntryIndex = -1;
        }

        function selectEntry(delta) {
            let newIndex = selectedEntryIndex;
            newIndex += delta;
            newIndex = Math.max(0, Math.min(entryElements.length - 1, newIndex))

            deselectEntries();
            selectEntryWithIndex(newIndex);
        }

        function selectEntryWithIndex(newIndex) {
            if (selectedEntryIndex >= 0)
                deselectEntries();

            input.blur();
            titleObject.blur();

            selectedEntryIndex = newIndex;
            entryElements[selectedEntryIndex].select();
        }

        function moveEntry(delta) {
            let newPosition = selectedEntryIndex + delta;
            newPosition = Math.max(0, Math.min(entryElements.length - 1, newPosition))

            if (newPosition != selectedEntryIndex) {
                send({
                    "action": 'move_entry',
                    "path": currentPath,
                    "currentIndex": selectedEntryIndex,
                    "newIndex": newPosition
                })
            }
            selectedIndexAfterUpdate = newPosition;
        }

        let selectedEntryIndex = -1;
        function globalKeyDownHandler(e) {
            if (e.key == 'Tab') {
                focusInput();
                return false;
            } else if (e.key == 'ArrowLeft') {
                if (e.altKey)
                    goBack();
                else {
                    if (selectedEntryIndex >= 0)
                        moveEntry(-1);
                }
            } else if (e.key == 'ArrowRight') {
                if (e.altKey) {
                    // goForward(); # TODO implement?
                } else {
                    if (selectedEntryIndex >= 0)
                        moveEntry(1);
                }
            } else if (e.key == 'ArrowUp') {
                if (e.altKey)
                    moveEntry(-1);
                else
                    selectEntry(-1);
            } else if (e.key == 'ArrowDown') {
                if (e.altKey)
                    moveEntry(1);
                else
                    selectEntry(1);
            } else if (e.key == 'Escape') {
                deselectEntries();
            } else if (e.key == 'Home') {
                if (entryElements.length > 0 && (selectedEntryIndex >= 0 || input.value.length == 0)) // so button can still be used in input field
                    selectEntryWithIndex(0);
            } else if (e.key == 'End') {
                if (entryElements.length > 0 && (selectedEntryIndex >= 0 || input.value.length == 0)) // so button can still be used in input field
                    selectEntryWithIndex(entryElements.length - 1);
            } else if (e.key == 'Enter') {
                if (selectedEntryIndex >= 0) {
                    entryElements[selectedEntryIndex].enter();
                    return false;
                }
            } else if (e.key == 'Delete') {
                if (selectedEntryIndex >= 0) {
                    entryElements[selectedEntryIndex].delete(askForConfirmationForSubtasks = !e.shiftKey);
                    return false;
                }
            } else if (e.key == 'F2') {
                deselectEntries();
                titleObject.focus(); // Does not focus title bar in root screen
                if (document.activeElement === titleObject) // Therefore this should not be executed then
                    document.execCommand('selectAll', false, null);

            } else {
                if (document.activeElement !== titleObject){
                    if (!e.shiftKey && !e.altKey && !e.controlKey)
                        focusInput();
                }
            }
        }
    </script>
</head>

<body onload="onLoad()">
    <div id='wrapper'>
        <div id="titleBar"></div>
        <div id="contentContainer"></div>
        <div class='spacer'></div>
        <div id="inputLine"></div>
    </div>
</body>
</html>
